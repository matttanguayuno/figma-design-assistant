<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DesignOps AI</title>
  <style>
    :root {
      --bg: #1e1e1e;
      --surface: #2d2d2d;
      --border: #3e3e3e;
      --text: #e0e0e0;
      --text-muted: #999;
      --accent: #6c5ce7;
      --accent-hover: #7c6df7;
      --success: #00b894;
      --danger: #d63031;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font);
      font-size: 12px;
      color: var(--text);
      background: var(--bg);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    label {
      font-weight: 600;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    textarea {
      width: 100%;
      min-height: 72px;
      padding: 10px;
      font-family: var(--font);
      font-size: 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      resize: vertical;
      outline: none;
      transition: border-color 0.15s;
    }

    textarea:focus {
      border-color: var(--accent);
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    button {
      flex: 1;
      padding: 8px 12px;
      font-family: var(--font);
      font-size: 12px;
      font-weight: 600;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, opacity 0.15s;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }

    .btn-danger {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid var(--border);
      flex: 0 0 auto;
      padding: 8px 16px;
    }
    .btn-danger:hover:not(:disabled) {
      color: var(--danger);
      border-color: var(--danger);
    }

    /* ── Cancel Button ──────────────────────────────── */
    .btn-cancel {
      flex: 1;
      padding: 8px 16px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      font-family: var(--font);
      font-size: 12px;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      display: none;
    }
    .btn-cancel:hover {
      color: var(--danger);
      border-color: var(--danger);
      background: rgba(214, 48, 49, 0.1);
    }

    /* ── Job List (parallel generate jobs) ───────────── */
    .job-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .job-list:empty {
      display: none;
    }
    .job-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      animation: menuFadeIn 0.15s ease;
    }
    .job-header {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .job-prompt {
      flex: 1;
      font-size: 11px;
      color: var(--text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .job-phase {
      flex: none;
      font-size: 9px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }
    .job-cancel {
      flex: none;
      width: 18px;
      height: 18px;
      padding: 0;
      border: none;
      background: transparent;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 11px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: color 0.15s, background 0.15s;
    }
    .job-cancel:hover {
      color: var(--danger);
      background: rgba(214, 48, 49, 0.15);
    }
    .job-bar-track {
      height: 3px;
      background: var(--border);
      border-radius: 2px;
      overflow: hidden;
    }
    .job-bar-fill {
      height: 100%;
      width: 0%;
      background: var(--accent);
      border-radius: 2px;
      transition: width 0.15s linear;
    }
    .job-item.done {
      border-color: var(--success);
      opacity: 0.7;
    }
    .job-item.done .job-bar-fill {
      width: 100% !important;
      background: var(--success);
    }
    .job-item.done .job-phase {
      color: var(--success);
    }
    .job-item.done .job-cancel {
      display: none;
    }
    .job-item.error {
      border-color: var(--danger);
      opacity: 0.7;
    }
    .job-item.error .job-bar-fill {
      background: var(--danger);
    }
    .job-item.error .job-phase {
      color: var(--danger);
    }
    .job-item.error .job-cancel {
      display: none;
    }
    .job-item.cancelled {
      opacity: 0.4;
    }
    .job-item.cancelled .job-cancel {
      display: none;
    }

    /* ── Progress Bar (Segmented) ───────────────────── */
    .progress-container {
      display: none;
      flex-direction: column;
      gap: 0;
    }
    .progress-container.visible {
      display: flex;
    }
    .progress-segments {
      display: flex;
      gap: 3px;
    }
    .progress-segment {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .segment-track {
      height: 4px;
      background: var(--surface);
      border-radius: 2px;
      overflow: hidden;
    }
    .segment-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      transition: width 0.15s linear;
      background: var(--accent);
    }
    .segment-label {
      text-align: center;
      font-size: 9px;
      color: var(--text-muted);
      opacity: 0.35;
      transition: opacity 0.3s, color 0.3s;
    }
    .progress-segment.active .segment-fill {
      background: var(--accent);
    }
    .progress-segment.active .segment-label {
      opacity: 1;
      color: var(--accent);
      font-weight: 600;
    }
    .progress-segment.done .segment-fill {
      width: 100% !important;
      background: var(--success);
    }
    .progress-segment.done .segment-label {
      opacity: 0.7;
      color: var(--success);
    }

    .status-bar {
      font-size: 10px;
      padding: 4px 0;
      border-radius: 0;
      background: transparent;
      color: var(--text-muted);
      text-align: center;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      border-top: 1px solid var(--border);
    }
    .status-bar::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-muted);
      flex-shrink: 0;
    }

    .status-bar.success {
      color: var(--success);
    }
    .status-bar.success::before {
      background: var(--success);
    }
    .status-bar.error {
      color: var(--danger);
    }
    .status-bar.error::before {
      background: var(--danger);
    }

    /* ── Label row with menu ─────────────────────────── */
    .label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .menu-wrapper {
      position: relative;
    }

    .menu-toggle {
      flex: none;
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
    }
    .menu-toggle:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .menu-toggle.open {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .menu-dropdown {
      display: none;
      position: absolute;
      right: 0;
      top: 32px;
      min-width: 230px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      z-index: 100;
      padding: 4px 0;
      animation: menuFadeIn 0.1s ease;
    }
    .menu-dropdown.show {
      display: block;
    }

    @keyframes menuFadeIn {
      from { opacity: 0; transform: translateY(-4px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 7px 12px;
      font-family: var(--font);
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      background: transparent;
      border: none;
      border-radius: 0;
      cursor: pointer;
      text-align: left;
      transition: background 0.1s;
    }
    .menu-item:hover {
      background: var(--accent);
      color: #fff;
    }
    .menu-item svg {
      flex-shrink: 0;
      width: 14px;
      height: 14px;
    }

    .menu-separator {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* ── Loading Overlay ─────────────────────────────── */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      z-index: 999;
      transition: opacity 0.3s;
    }
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--surface);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* ── Settings Panel ──────────────────────────────── */
    .settings-panel {
      display: none;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      animation: menuFadeIn 0.15s ease;
    }
    .settings-panel.visible {
      display: flex;
    }
    .settings-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .settings-row {
      display: flex;
      gap: 6px;
    }
    .settings-input {
      flex: 1;
      padding: 6px 8px;
      font-family: var(--font);
      font-size: 11px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      outline: none;
    }
    .settings-input:focus {
      border-color: var(--accent);
    }
    .settings-input::placeholder {
      color: var(--text-muted);
      opacity: 0.5;
    }
    .btn-save-key {
      flex: none;
      padding: 6px 10px;
      font-family: var(--font);
      font-size: 11px;
      font-weight: 600;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .btn-save-key:hover {
      background: var(--accent-hover);
    }
    .key-status {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .key-status.connected {
      color: var(--success);
    }
    .key-status.missing {
      color: var(--danger);
    }
    .key-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .key-status.connected .key-dot {
      background: var(--success);
    }
    .key-status.missing .key-dot {
      background: var(--danger);
    }
    .key-status.validating {
      color: var(--muted);
    }
    .key-status.validating .key-dot {
      background: var(--muted);
      animation: pulse-dot 1s ease-in-out infinite;
    }
    .key-status.error {
      color: var(--danger);
    }
    .key-status.error .key-dot {
      background: var(--danger);
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    .settings-select {
      width: 100%;
      padding: 6px 8px;
      font-family: var(--font);
      font-size: 11px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      outline: none;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%23999' stroke-width='1.5' fill='none' stroke-linecap='round'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 8px center;
      padding-right: 24px;
    }
    .settings-select:focus {
      border-color: var(--accent);
    }
    .settings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .settings-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
    }
    .btn-close-settings {
      width: 22px;
      height: 22px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      border-radius: 4px;
      cursor: pointer;
      flex: none;
    }
    .btn-close-settings:hover {
      background: var(--border);
      color: var(--text);
    }
    /* When settings view is open, hide prompt area and show only settings */
    body.settings-open > div:first-of-type,
    body.settings-open > .btn-row,
    body.settings-open > #progress-container,
    body.settings-open > #status-bar {
      display: none !important;
    }

    /* ── Audit Panel (full-page takeover) ─────────────────────── */
    .audit-panel {
      position: absolute;
      inset: 0;
      z-index: 100;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .audit-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .audit-title {
      font-weight: 700;
      font-size: 13px;
      color: var(--text);
    }
    .audit-header-actions {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .btn-clear-audit {
      flex: none;
      padding: 4px 10px;
      font-size: 10px;
      font-weight: 600;
      border-radius: 4px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      cursor: pointer;
    }
    .btn-clear-audit:hover {
      background: var(--border);
      color: var(--text);
    }
    .btn-close-audit {
      flex: none;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      padding: 0;
    }
    .btn-close-audit:hover {
      background: var(--border);
      color: var(--text);
    }
    .audit-summary {
      padding: 8px 14px;
      font-size: 11px;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .audit-findings {
      overflow-y: auto;
      flex: 1;
      padding: 4px 0;
    }
    /* ── Group header (one per check type) ──────────────────── */
    .audit-group {
      border-bottom: 1px solid var(--border);
    }
    .audit-group:last-child {
      border-bottom: none;
    }
    .audit-group-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      cursor: pointer;
      user-select: none;
      transition: background 0.12s;
    }
    .audit-group-header:hover {
      background: rgba(255,255,255,0.04);
    }
    .audit-group-chevron {
      width: 12px;
      height: 12px;
      flex-shrink: 0;
      transition: transform 0.15s;
      color: var(--text-muted);
    }
    .audit-group.collapsed .audit-group-chevron {
      transform: rotate(-90deg);
    }
    .audit-group-icon {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
      background: #f39c12;
    }
    .audit-group-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }
    .audit-group-count {
      font-size: 10px;
      color: var(--text-muted);
      background: var(--surface);
      padding: 1px 7px;
      border-radius: 8px;
      flex-shrink: 0;
    }
    .audit-group-items {
      overflow: hidden;
    }
    .audit-group.collapsed .audit-group-items {
      display: none;
    }
    /* ── Individual finding item ──────────────────────────── */
    .audit-finding {
      padding: 6px 14px 6px 36px;
      cursor: pointer;
      transition: background 0.12s;
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }
    .audit-finding:hover {
      background: rgba(255,255,255,0.04);
    }
    .audit-finding-body {
      flex: 1;
      min-width: 0;
    }
    .audit-node-name {
      font-size: 10px;
      font-weight: 600;
      color: var(--primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .audit-message {
      font-size: 11px;
      color: var(--text-muted);
      line-height: 1.4;
      margin-top: 1px;
    }
    .audit-suggestion {
      margin-top: 3px;
      font-size: 10px;
      color: var(--success);
      line-height: 1.3;
    }
    .audit-suggestion::before {
      content: "\1F4A1 ";
    }
    .audit-navigate {
      flex-shrink: 0;
      color: var(--text-muted);
      margin-top: 2px;
    }
    /* ── Audit Progress Bar ──────────────────────────────── */
    .audit-progress {
      padding: 6px 14px 8px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }
    .audit-progress.hidden { display: none; }
    .audit-progress-segments {
      display: flex;
      gap: 3px;
    }
    .audit-progress-seg {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .audit-progress-seg .seg-track {
      height: 4px;
      background: var(--surface);
      border-radius: 2px;
      overflow: hidden;
    }
    .audit-progress-seg .seg-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      transition: width 0.15s linear;
      background: var(--accent);
    }
    .audit-progress-seg .seg-label {
      text-align: center;
      font-size: 9px;
      color: var(--text-muted);
      opacity: 0.35;
      transition: opacity 0.3s, color 0.3s;
    }
    .audit-progress-seg.active .seg-fill { background: var(--accent); }
    .audit-progress-seg.active .seg-label { opacity: 1; color: var(--accent); font-weight: 600; }
    .audit-progress-seg.done .seg-fill { width: 100% !important; background: var(--success); }
    .audit-progress-seg.done .seg-label { opacity: 0.7; color: var(--success); }
  </style>
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Initializing…</div>
  </div>

  <div>
    <div class="label-row">
      <label for="intent">Describe changes</label>
      <div class="menu-wrapper">
        <button id="menu-toggle" class="menu-toggle" title="Menu" aria-label="Menu">
          <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
            <path d="M8 9.5L4 5.5h8L8 9.5z" fill="currentColor"/>
          </svg>
        </button>
        <div id="menu-dropdown" class="menu-dropdown">
          <button class="menu-item" id="menu-export-json">
            <svg viewBox="0 0 16 16" fill="none"><path d="M4 1h5l4 4v9a1 1 0 01-1 1H4a1 1 0 01-1-1V2a1 1 0 011-1z" stroke="currentColor" stroke-width="1.2"/><path d="M9 1v4h4" stroke="currentColor" stroke-width="1.2"/><path d="M6 9l2 2 2-2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            Export to JSON
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-import-json">
            <svg viewBox="0 0 16 16" fill="none"><path d="M4 1h5l4 4v9a1 1 0 01-1 1H4a1 1 0 01-1-1V2a1 1 0 011-1z" stroke="currentColor" stroke-width="1.2"/><path d="M9 1v4h4" stroke="currentColor" stroke-width="1.2"/><path d="M6 11l2-2 2 2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            Import from JSON
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-export-docs">
            <svg viewBox="0 0 16 16" fill="none"><path d="M4 1h5l4 4v9a1 1 0 01-1 1H4a1 1 0 01-1-1V2a1 1 0 011-1z" stroke="currentColor" stroke-width="1.2"/><path d="M9 1v4h4" stroke="currentColor" stroke-width="1.2"/><path d="M5 8h6M5 10.5h4" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/></svg>
            Export Design Docs
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-audit-a11y">
            <svg viewBox="0 0 16 16" fill="none"><circle cx="8" cy="8" r="6.5" stroke="currentColor" stroke-width="1.2"/><path d="M8 5v4M8 11h.01" stroke="currentColor" stroke-width="1.4" stroke-linecap="round"/></svg>
            Audit Accessibility
          </button>
          <button class="menu-item" id="menu-clear-a11y">
            <svg viewBox="0 0 16 16" fill="none"><path d="M2 4h12M5 4V3a1 1 0 011-1h4a1 1 0 011 1v1M6 7v5M10 7v5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 4l1 10a1 1 0 001 1h6a1 1 0 001-1l1-10" stroke="currentColor" stroke-width="1.2"/></svg>
            Clear Accessibility Warnings
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-settings">
            <svg viewBox="0 0 16 16" fill="none"><path d="M6.5 1h3l.4 2 1.3.7 1.8-1 2.1 2.1-1 1.8.7 1.3 2 .4v3l-2 .4-1.3.7 1 1.8-2.1 2.1-1.8-1-.7 1.3-.4 2h-3l-.4-2-1.3-.7-1.8 1L.9 13.1l1-1.8L1.2 10l-2-.4v-3l2-.4.7-1.3-1-1.8L3 .9l1.8 1L6.1 1.2l.4-2z" stroke="currentColor" stroke-width="1.1"/><circle cx="8" cy="8" r="2.5" stroke="currentColor" stroke-width="1.1"/></svg>
            Settings
          </button>
        </div>
      </div>
    </div>
    <textarea
      id="intent"
      placeholder="e.g. Add a login screen, make the header larger, change background to blue…"
    ></textarea>
  </div>

  <div class="btn-row">
    <button id="btn-apply" class="btn-primary" disabled>Apply</button>
    <button id="btn-cancel" class="btn-cancel">Cancel</button>
  </div>

  <div id="settings-panel" class="settings-panel">
    <div class="settings-header">
      <span class="settings-title">Settings</span>
      <button id="btn-close-settings" class="btn-close-settings" title="Close settings">
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2 2l8 8M10 2l-8 8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
      </button>
    </div>
    <div class="settings-label">Provider</div>
    <select id="provider-select" class="settings-select">
      <option value="anthropic">Anthropic</option>
      <option value="openai">OpenAI</option>
      <option value="gemini">Google Gemini</option>
    </select>
    <div class="settings-label">Model</div>
    <select id="model-select" class="settings-select"></select>
    <div class="settings-label" id="api-key-label">Anthropic API Key</div>
    <div class="settings-row">
      <input id="api-key-input" class="settings-input" type="password" placeholder="sk-ant-api03-…" spellcheck="false" autocomplete="off" />
      <button id="btn-save-key" class="btn-save-key">Save</button>
    </div>
    <div id="key-status" class="key-status missing">
      <span class="key-dot"></span>
      <span id="key-status-text">No API key configured</span>
    </div>
  </div>

  <div id="progress-container" class="progress-container">
    <div class="progress-segments">
      <div class="progress-segment" data-step="analyze">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Analyzing</div>
      </div>
      <div class="progress-segment" data-step="generate">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Generating</div>
      </div>
      <div class="progress-segment" data-step="create">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Creating</div>
      </div>
    </div>
  </div>

  <!-- Parallel generate job list -->
  <div id="job-list" class="job-list"></div>

  <!-- Accessibility audit results panel -->
  <div id="audit-panel" class="audit-panel" style="display:none;">
    <div class="audit-header">
      <span class="audit-title">Accessibility Audit</span>
      <div class="audit-header-actions">
        <button id="btn-clear-audit" class="btn-clear-audit" title="Clear badges &amp; close">Clear</button>
        <button id="btn-close-audit" class="btn-close-audit" title="Close panel">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2 2l8 8M10 2l-8 8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>
        </button>
      </div>
    </div>
    <div id="audit-progress" class="audit-progress hidden">
      <div class="audit-progress-segments">
        <div class="audit-progress-seg" data-audit-step="scanning">
          <div class="seg-track"><div class="seg-fill"></div></div>
          <div class="seg-label">Scanning</div>
        </div>
        <div class="audit-progress-seg" data-audit-step="enhancing">
          <div class="seg-track"><div class="seg-fill"></div></div>
          <div class="seg-label">Enhancing</div>
        </div>
      </div>
    </div>
    <div id="audit-summary" class="audit-summary"></div>
    <div id="audit-findings" class="audit-findings"></div>
  </div>

  <div id="status-bar" class="status-bar">Nothing selected — will generate new frame</div>

  <!-- Hidden file input for JSON import -->
  <input type="file" id="file-input" accept=".json" style="display:none" />

  <script>
    // ── DOM References ────────────────────────────────────────────
    const intentEl = document.getElementById("intent");
    const btnApply = document.getElementById("btn-apply");
    const btnCancel = document.getElementById("btn-cancel");
    const statusBar = document.getElementById("status-bar");
    const menuToggle = document.getElementById("menu-toggle");
    const menuDropdown = document.getElementById("menu-dropdown");
    const menuExportJson = document.getElementById("menu-export-json");
    const menuImportJson = document.getElementById("menu-import-json");
    const menuExportDocs = document.getElementById("menu-export-docs");
    const fileInput = document.getElementById("file-input");
    const progressContainer = document.getElementById("progress-container");
    const progressSegments = document.querySelectorAll(".progress-segment");
    const jobListEl = document.getElementById("job-list");
    const settingsPanel = document.getElementById("settings-panel");
    const apiKeyInput = document.getElementById("api-key-input");
    const btnSaveKey = document.getElementById("btn-save-key");
    const keyStatus = document.getElementById("key-status");
    const keyStatusText = document.getElementById("key-status-text");
    const menuSettings = document.getElementById("menu-settings");
    const btnCloseSettings = document.getElementById("btn-close-settings");
    const providerSelect = document.getElementById("provider-select");
    const modelSelect = document.getElementById("model-select");
    const apiKeyLabel = document.getElementById("api-key-label");
    const menuAuditA11y = document.getElementById("menu-audit-a11y");
    const menuClearA11y = document.getElementById("menu-clear-a11y");
    const auditPanel = document.getElementById("audit-panel");
    const auditSummary = document.getElementById("audit-summary");
    const auditFindings = document.getElementById("audit-findings");
    const btnClearAudit = document.getElementById("btn-clear-audit");
    const btnCloseAudit = document.getElementById("btn-close-audit");
    const auditProgressEl = document.getElementById("audit-progress");

    // ── Provider / Model configuration ───────────────────────────
    const PROVIDER_MODELS = {
      anthropic: [
        { id: "claude-opus-4-20250514", label: "Claude Opus 4" },
        { id: "claude-sonnet-4-20250514", label: "Claude Sonnet 4" },
        { id: "claude-haiku-4-20250414", label: "Claude Haiku 4" },
      ],
      openai: [
        { id: "gpt-4o", label: "GPT-4o" },
        { id: "gpt-4o-mini", label: "GPT-4o Mini" },
        { id: "o3-mini", label: "o3-mini" },
      ],
      gemini: [
        { id: "gemini-2.5-pro", label: "Gemini 2.5 Pro" },
        { id: "gemini-2.5-flash", label: "Gemini 2.5 Flash" },
        { id: "gemini-2.0-flash", label: "Gemini 2.0 Flash" },
      ],
    };
    const PROVIDER_KEY_LABELS = {
      anthropic: "Anthropic API Key",
      openai: "OpenAI API Key",
      gemini: "Google Gemini API Key",
    };
    const PROVIDER_KEY_PLACEHOLDERS = {
      anthropic: "sk-ant-api03-\u2026",
      openai: "sk-\u2026",
      gemini: "AIza\u2026",
    };

    // ── Provider state ──────────────────────────────────────────
    let _selectedProvider = "anthropic";
    let _selectedModel = "claude-sonnet-4-20250514";
    // Store keys per provider
    let _providerKeys = { anthropic: "", openai: "", gemini: "" };

    // ── API Key state ────────────────────────────────────────────
    let _apiKey = "";

    function updateKeyStatus(key) {
      _apiKey = key || "";
      _providerKeys[_selectedProvider] = _apiKey;
      if (_apiKey) {
        keyStatus.className = "key-status active";
        keyStatusText.textContent = "API key configured";
        btnApply.disabled = false;
      } else {
        keyStatus.className = "key-status missing";
        keyStatusText.textContent = "No API key configured";
        btnApply.disabled = true;
      }
    }

    function populateModelDropdown(provider) {
      const models = PROVIDER_MODELS[provider] || [];
      modelSelect.innerHTML = "";
      models.forEach(function(m) {
        const opt = document.createElement("option");
        opt.value = m.id;
        opt.textContent = m.label;
        modelSelect.appendChild(opt);
      });
      if (models.length > 0) {
        _selectedModel = models[0].id;
        modelSelect.value = _selectedModel;
      }
    }

    function switchProvider(provider) {
      _selectedProvider = provider;
      providerSelect.value = provider;
      // Update model dropdown
      populateModelDropdown(provider);
      // Update key label and placeholder
      apiKeyLabel.textContent = PROVIDER_KEY_LABELS[provider] || "API Key";
      apiKeyInput.value = "";
      const savedKey = _providerKeys[provider] || "";
      if (savedKey) {
        apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[provider].slice(0, -1) + savedKey.slice(-4);
      } else {
        apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[provider] || "Enter API key\u2026";
      }
      // Update key status for this provider
      updateKeyStatus(savedKey);
    }

    // Initialize model dropdown
    populateModelDropdown("anthropic");

    providerSelect.addEventListener("change", function() {
      switchProvider(providerSelect.value);
      postToPlugin({ type: "save-provider-selection", provider: _selectedProvider, model: _selectedModel });
    });

    modelSelect.addEventListener("change", function() {
      _selectedModel = modelSelect.value;
      postToPlugin({ type: "save-provider-selection", provider: _selectedProvider, model: _selectedModel });
    });

    // Track whether anything is selected to update button label
    let hasSelection = false;
    function updateButtonLabel(selected) {
      hasSelection = selected;
      btnApply.textContent = selected ? "Apply" : "Generate";
    }

    // ── Progress Bar (segmented, timing-adaptive) ──────────────────
    //
    // Strategy: 3 independent segments, one per phase. The active
    // segment fills based on estimated time; completed segments snap
    // to 100% green. No positional confusion — label sits below its bar.
    // After each run, timings are persisted via figma.clientStorage.

    // Default estimates (ms). Updated after each successful run.
    let phaseEstimates = { analyze: 5000, generate: 45000, create: 4000 };
    const PHASE_ORDER = ["analyze", "generate", "create"];

    let _progressInterval = null;
    let _progressPhase = "";
    let _phaseStartTime = 0;
    let _phaseTimings = {};

    function getSegmentFill(phase) {
      const seg = document.querySelector('.progress-segment[data-step="' + phase + '"]');
      return seg ? seg.querySelector(".segment-fill") : null;
    }

    function startProgress(phase) {
      progressContainer.classList.add("visible");
      _progressPhase = phase || "analyze";
      _phaseStartTime = Date.now();
      _phaseTimings = {};
      _phaseTimings[_progressPhase] = Date.now();
      // Reset all segments
      progressSegments.forEach(function(seg) {
        seg.classList.remove("active", "done");
        seg.querySelector(".segment-fill").style.width = "0%";
      });
      updateStepIndicators(_progressPhase);
      if (_progressInterval) clearInterval(_progressInterval);
      _progressInterval = setInterval(tickProgress, 80);
    }

    function tickProgress() {
      var fill = getSegmentFill(_progressPhase);
      if (!fill) return;
      var est = phaseEstimates[_progressPhase] || 30000;
      var elapsed = Date.now() - _phaseStartTime;
      var pct;
      if (elapsed < est) {
        pct = 85 * (elapsed / est);
      } else {
        var overtime = elapsed - est;
        pct = 85 + 13 * (1 - Math.exp(-overtime / (est * 0.5)));
      }
      fill.style.width = Math.min(pct, 98).toFixed(1) + "%";
    }

    function advanceToPhase(phase) {
      if (phase === _progressPhase) return;

      // Record timing for finished phase
      var prevPhase = _progressPhase;
      if (_phaseTimings[prevPhase]) {
        var actualMs = Date.now() - _phaseTimings[prevPhase];
        phaseEstimates[prevPhase] = Math.round(actualMs * 0.7 + phaseEstimates[prevPhase] * 0.3);
      }

      // Mark previous segment as done (CSS handles 100% fill + green)
      var prevSeg = document.querySelector('.progress-segment[data-step="' + prevPhase + '"]');
      if (prevSeg) { prevSeg.classList.remove("active"); prevSeg.classList.add("done"); }

      if (phase === "done") {
        // Mark all segments done
        progressSegments.forEach(function(seg) {
          seg.classList.remove("active");
          seg.classList.add("done");
        });
        if (_progressInterval) { clearInterval(_progressInterval); _progressInterval = null; }
        // Save timings to plugin sandbox for persistence
        postToPlugin({ type: "save-timings", timings: phaseEstimates });
        return;
      }

      _progressPhase = phase;
      _phaseStartTime = Date.now();
      _phaseTimings[phase] = Date.now();
      updateStepIndicators(phase);
    }

    function updateStepIndicators(phase) {
      var idx = PHASE_ORDER.indexOf(phase);
      progressSegments.forEach(function(seg, i) {
        seg.classList.remove("active", "done");
        if (i < idx) seg.classList.add("done");
        else if (i === idx) seg.classList.add("active");
      });
    }

    function stopProgress() {
      if (_progressInterval) clearInterval(_progressInterval);
      _progressInterval = null;
      progressContainer.classList.remove("visible");
      progressSegments.forEach(function(seg) {
        seg.classList.remove("active", "done");
        seg.querySelector(".segment-fill").style.width = "0%";
      });
    }

    function showWorking() {
      btnApply.style.display = "none";
      btnCancel.style.display = "block";
      statusBar.style.display = "none";
    }

    function hideWorking() {
      btnApply.style.display = "block";
      btnCancel.style.display = "none";
      btnApply.disabled = !_apiKey;
      statusBar.style.display = "flex";
    }

    // ── Helpers ───────────────────────────────────────────────────
    function setStatus(msg, type) {
      statusBar.textContent = msg;
      statusBar.className = "status-bar" + (type ? " " + type : "");
    }

    // Track current selection label for restoring after transient status
    let _selectionLabel = "Nothing selected";
    function setSelectionStatus(msg) {
      _selectionLabel = msg;
      // Only update if we're not showing a transient status (success/error)
      if (!statusBar.classList.contains("success") && !statusBar.classList.contains("error")) {
        statusBar.textContent = msg;
        statusBar.className = "status-bar";
      }
    }

    // Override setStatus to auto-revert to selection label after success/error
    const _origSetStatus = setStatus;
    function setStatus(msg, type) {
      statusBar.textContent = msg;
      statusBar.className = "status-bar" + (type ? " " + type : "");
      // Revert to selection status after a few seconds for success/error
      if (type === "success" || type === "error") {
        setTimeout(() => {
          // Only revert if it's still showing the same message
          if (statusBar.textContent === msg) {
            statusBar.textContent = _selectionLabel;
            statusBar.className = "status-bar";
          }
        }, 4000);
      }
    }

    // ── Send to Plugin ────────────────────────────────────────────
    function postToPlugin(msg) {
      parent.postMessage({ pluginMessage: msg }, "*");
    }

    // ── Menu Toggle ──────────────────────────────────────────────
    menuToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = menuDropdown.classList.toggle("show");
      menuToggle.classList.toggle("open", isOpen);
    });

    // Close menu when clicking outside
    document.addEventListener("click", (e) => {
      if (!menuDropdown.contains(e.target) && e.target !== menuToggle) {
        menuDropdown.classList.remove("show");
        menuToggle.classList.remove("open");
      }
    });

    // ── Menu: Settings ──────────────────────────────────────────
    function openSettings() {
      settingsPanel.classList.add("visible");
      document.body.classList.add("settings-open");
    }
    function closeSettings() {
      settingsPanel.classList.remove("visible");
      document.body.classList.remove("settings-open");
    }
    menuSettings.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      openSettings();
    });
    btnCloseSettings.addEventListener("click", () => {
      closeSettings();
    });

    // ── Save API Key ─────────────────────────────────────────────
    btnSaveKey.addEventListener("click", async () => {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Please enter an API key.", "error");
        return;
      }

      // Show validating state
      btnSaveKey.disabled = true;
      btnSaveKey.textContent = "Validating…";
      keyStatus.className = "key-status validating";
      keyStatusText.textContent = "Validating API key…";

      try {
        const resp = await fetch(BACKEND_URL + "/validate-key", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ apiKey: key, provider: _selectedProvider }),
        });
        const result = await resp.json();

        if (result.valid) {
          // Key is valid — save it
          updateKeyStatus(key);
          postToPlugin({ type: "save-api-key", key: key, provider: _selectedProvider });
          apiKeyInput.value = "";
          apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[_selectedProvider].slice(0, -1) + key.slice(-4);
          setStatus(result.warning || "API key verified and saved.", result.warning ? "warning" : "success");
        } else {
          // Key is invalid
          keyStatus.className = "key-status error";
          keyStatusText.textContent = result.error || "Invalid API key.";
          setStatus(result.error || "Invalid API key.", "error");
        }
      } catch (err) {
        // Network / backend unreachable — save anyway but warn
        updateKeyStatus(key);
        postToPlugin({ type: "save-api-key", key: key, provider: _selectedProvider });
        apiKeyInput.value = "";
        apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[_selectedProvider].slice(0, -1) + key.slice(-4);
        setStatus("Could not validate key (backend unreachable). Key saved.", "warning");
      } finally {
        btnSaveKey.disabled = false;
        btnSaveKey.textContent = "Save";
      }
    });

    // ── Menu: Export design to JSON ──────────────────────────────
    menuExportJson.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      setStatus("Exporting design to JSON…");
      postToPlugin({ type: "export-json" });
    });
    // \u2500\u2500 Menu: Import design from JSON \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
    menuImportJson.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      fileInput.value = "";
      fileInput.click();
    });

    // ── Menu: Export Design Docs ─────────────────────────────────
    menuExportDocs.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      setStatus("Generating design docs…");
      postToPlugin({ type: "generate-docs" });
    });

    // ── Menu: Audit Accessibility ───────────────────────────────
    menuAuditA11y.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      auditPanel.style.display = "flex";
      auditSummary.textContent = "";
      auditFindings.innerHTML = "";
      startAuditProgress("all"); // scope will be corrected by plugin response
      setStatus("Running accessibility audit…");
      postToPlugin({ type: "audit-a11y" });
    });

    // ── Menu: Clear Accessibility Warnings ──────────────────────
    menuClearA11y.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      postToPlugin({ type: "clear-audit" });
      auditPanel.style.display = "none";
      setStatus("Accessibility warnings cleared.", "success");
    });

    // ── Audit panel: Close ──────────────────────────────────────
    btnCloseAudit.addEventListener("click", () => {
      auditPanel.style.display = "none";
    });

    // ── Audit panel: Clear badges & close ───────────────────────
    btnClearAudit.addEventListener("click", () => {
      postToPlugin({ type: "clear-audit" });
      auditPanel.style.display = "none";
      setStatus("Audit cleared.", "success");
    });

    // ── Audit Progress Bar Logic ─────────────────────────────────────
    // Two phases: scanning (local WCAG checks) → enhancing (LLM suggestions)
    // Estimates adjust over time per scope: all / frame / component
    var auditEstimates = {
      all:       { scanning: 4000, enhancing: 12000 },
      frame:     { scanning: 1500, enhancing: 10000 },
      component: { scanning: 500,  enhancing: 8000 }
    };
    var AUDIT_PHASES = ["scanning", "enhancing"];
    var _auditProgressInterval = null;
    var _auditPhase = "";
    var _auditPhaseStart = 0;
    var _auditScope = "all";
    var _auditPhaseTimings = {};

    function getAuditFill(phase) {
      var seg = document.querySelector('.audit-progress-seg[data-audit-step="' + phase + '"]');
      return seg ? seg.querySelector(".seg-fill") : null;
    }

    function startAuditProgress(scope) {
      _auditScope = scope || "all";
      _auditPhase = "scanning";
      _auditPhaseStart = Date.now();
      _auditPhaseTimings = {};
      _auditPhaseTimings[_auditPhase] = Date.now();
      auditProgressEl.classList.remove("hidden");
      // Reset segments
      var segs = auditProgressEl.querySelectorAll(".audit-progress-seg");
      segs.forEach(function(s) {
        s.classList.remove("active", "done");
        s.querySelector(".seg-fill").style.width = "0%";
      });
      updateAuditStepIndicators("scanning");
      if (_auditProgressInterval) clearInterval(_auditProgressInterval);
      _auditProgressInterval = setInterval(tickAuditProgress, 80);
    }

    function tickAuditProgress() {
      var fill = getAuditFill(_auditPhase);
      if (!fill) return;
      var ests = auditEstimates[_auditScope] || auditEstimates.all;
      var est = ests[_auditPhase] || 5000;
      var elapsed = Date.now() - _auditPhaseStart;
      var pct;
      if (elapsed < est) {
        pct = 85 * (elapsed / est);
      } else {
        var overtime = elapsed - est;
        pct = 85 + 13 * (1 - Math.exp(-overtime / (est * 0.5)));
      }
      fill.style.width = Math.min(pct, 98).toFixed(1) + "%";
    }

    function advanceAuditPhase(phase) {
      if (phase === _auditPhase) return;
      // Record timing for finished phase
      var prev = _auditPhase;
      var ests = auditEstimates[_auditScope] || auditEstimates.all;
      if (_auditPhaseTimings[prev]) {
        var actualMs = Date.now() - _auditPhaseTimings[prev];
        ests[prev] = Math.round(actualMs * 0.7 + (ests[prev] || 5000) * 0.3);
      }
      // Mark previous done
      var prevSeg = document.querySelector('.audit-progress-seg[data-audit-step="' + prev + '"]');
      if (prevSeg) { prevSeg.classList.remove("active"); prevSeg.classList.add("done"); }

      if (phase === "done") {
        // All done
        var segs = auditProgressEl.querySelectorAll(".audit-progress-seg");
        segs.forEach(function(s) { s.classList.remove("active"); s.classList.add("done"); });
        if (_auditProgressInterval) { clearInterval(_auditProgressInterval); _auditProgressInterval = null; }
        // Save estimates
        postToPlugin({ type: "save-audit-timings", timings: auditEstimates });
        // Hide after a moment
        setTimeout(function() { auditProgressEl.classList.add("hidden"); }, 1200);
        return;
      }

      _auditPhase = phase;
      _auditPhaseStart = Date.now();
      _auditPhaseTimings[phase] = Date.now();
      updateAuditStepIndicators(phase);
    }

    function updateAuditStepIndicators(phase) {
      var idx = AUDIT_PHASES.indexOf(phase);
      var segs = auditProgressEl.querySelectorAll(".audit-progress-seg");
      segs.forEach(function(s, i) {
        s.classList.remove("active", "done");
        if (i < idx) s.classList.add("done");
        else if (i === idx) s.classList.add("active");
      });
    }

    function stopAuditProgress() {
      if (_auditProgressInterval) clearInterval(_auditProgressInterval);
      _auditProgressInterval = null;
      auditProgressEl.classList.add("hidden");
      var segs = auditProgressEl.querySelectorAll(".audit-progress-seg");
      segs.forEach(function(s) {
        s.classList.remove("active", "done");
        s.querySelector(".seg-fill").style.width = "0%";
      });
    }

    /** Human-readable labels for check types */
    var CHECK_TYPE_LABELS = {
      "contrast":     "Low contrast text",
      "font-size":    "Small font size",
      "empty-text":   "Empty text node",
      "touch-target": "Undersized touch target",
      "low-opacity":  "Low opacity element"
    };

    /** Render audit findings grouped by check type */
    function renderAuditFindings(findings) {
      auditFindings.innerHTML = "";

      if (!findings || findings.length === 0) {
        auditSummary.textContent = "No accessibility issues found!";
        return;
      }

      auditSummary.textContent = findings.length + " issue" + (findings.length === 1 ? "" : "s") + " found";

      // Group findings by checkType
      var groups = {};
      var groupOrder = [];
      findings.forEach(function(f) {
        if (!groups[f.checkType]) {
          groups[f.checkType] = [];
          groupOrder.push(f.checkType);
        }
        groups[f.checkType].push(f);
      });

      groupOrder.forEach(function(checkType) {
        var items = groups[checkType];
        var label = CHECK_TYPE_LABELS[checkType] || checkType;

        var groupEl = document.createElement("div");
        groupEl.className = "audit-group collapsed";

        // Group header
        var headerEl = document.createElement("div");
        headerEl.className = "audit-group-header";
        headerEl.innerHTML =
          '<svg class="audit-group-chevron" viewBox="0 0 12 12" fill="none"><path d="M4 2l4 4-4 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>' +
          '<span class="audit-group-icon"></span>' +
          '<span class="audit-group-label">' + escapeHtml(label) + '</span>' +
          '<span class="audit-group-count">' + items.length + '</span>';
        headerEl.addEventListener("click", function() {
          groupEl.classList.toggle("collapsed");
        });
        groupEl.appendChild(headerEl);

        // Group items container
        var itemsEl = document.createElement("div");
        itemsEl.className = "audit-group-items";

        items.forEach(function(f) {
          var el = document.createElement("div");
          el.className = "audit-finding";
          el.addEventListener("click", function() {
            postToPlugin({ type: "select-node", nodeId: f.nodeId });
          });

          var bodyHtml =
            '<div class="audit-finding-body">' +
              '<div class="audit-node-name">' + escapeHtml(f.nodeName) + '</div>' +
              '<div class="audit-message">' + escapeHtml(f.message) + '</div>' +
              (f.suggestion ? '<div class="audit-suggestion">' + escapeHtml(f.suggestion) + '</div>' : '') +
            '</div>' +
            '<svg class="audit-navigate" width="10" height="10" viewBox="0 0 10 10" fill="none"><path d="M3 1l4 4-4 4" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>';

          el.innerHTML = bodyHtml;
          itemsEl.appendChild(el);
        });

        groupEl.appendChild(itemsEl);
        auditFindings.appendChild(groupEl);
      });
    }

    function escapeHtml(str) {
      if (!str) return "";
      return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      setStatus("Reading JSON file\u2026");
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!data.selection || !data.selection.nodes) {
            setStatus("Invalid JSON: missing selection.nodes", "error");
            return;
          }
          setStatus("Importing design\u2026");
          postToPlugin({ type: "import-json", data: data });
        } catch (err) {
          setStatus("Invalid JSON file: " + err.message, "error");
        }
      };
      reader.onerror = () => setStatus("Failed to read file.", "error");
      reader.readAsText(file);
    });

    // ── Menu: Generate Frame ────────────────────────────────────
    // Removed — Generate is now handled automatically by Apply when nothing is selected
    function downloadJson(data) {
      const json = JSON.stringify(data, null, 2);
      const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(json);
      const a = document.createElement("a");
      a.href = dataUri;
      a.download = "design-export.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    function downloadMarkdown(markdown, filename) {
      const dataUri = "data:text/markdown;charset=utf-8," + encodeURIComponent(markdown);
      const a = document.createElement("a");
      a.href = dataUri;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // ── Fetch Proxy (real AbortController for instant cancel) ──────
    // ▸ For local development:  "http://localhost:3001"
    // ▸ For Render deployment:  "https://figma-design-assistant.onrender.com"
    const BACKEND_URL = "https://figma-design-assistant.onrender.com";

    // Serial fetch (plan+apply) — single AbortController
    let _activeFetchAbort = null;

    // Parallel fetch (generate jobs) — per-seq AbortControllers
    const _fetchAborts = new Map();      // seq -> AbortController
    const _jobIdToSeqs = new Map();      // jobId -> Set<seq>

    function doFetchForPlugin(endpoint, body, seq, jobId) {
      if (jobId !== undefined) {
        // Parallel mode — don't abort other fetches
        const ac = new AbortController();
        _fetchAborts.set(seq, ac);
        if (!_jobIdToSeqs.has(jobId)) _jobIdToSeqs.set(jobId, new Set());
        _jobIdToSeqs.get(jobId).add(seq);
        fetch(BACKEND_URL + endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          signal: ac.signal,
        })
          .then(async (resp) => {
            _fetchAborts.delete(seq);
            if (!resp.ok) {
              const errText = await resp.text();
              postToPlugin({ type: "fetch-error", error: "Backend error " + resp.status + ": " + errText, seq });
            } else {
              const data = await resp.json();
              postToPlugin({ type: "fetch-result", data, seq });
            }
          })
          .catch((err) => {
            _fetchAborts.delete(seq);
            if (err.name === "AbortError") {
              postToPlugin({ type: "fetch-aborted", seq });
            } else {
              postToPlugin({ type: "fetch-error", error: err.message, seq });
            }
          });
      } else {
        // Serial mode (plan+apply) — abort any prior serial fetch
        if (_activeFetchAbort) { _activeFetchAbort.abort(); _activeFetchAbort = null; }
        const ac = new AbortController();
        _activeFetchAbort = ac;
        fetch(BACKEND_URL + endpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
          signal: ac.signal,
        })
          .then(async (resp) => {
            _activeFetchAbort = null;
            if (!resp.ok) {
              const errText = await resp.text();
              postToPlugin({ type: "fetch-error", error: "Backend error " + resp.status + ": " + errText, seq });
            } else {
              const data = await resp.json();
              postToPlugin({ type: "fetch-result", data, seq });
            }
          })
          .catch((err) => {
            _activeFetchAbort = null;
            if (err.name === "AbortError") {
              postToPlugin({ type: "fetch-aborted", seq });
            } else {
              postToPlugin({ type: "fetch-error", error: err.message, seq });
            }
          });
      }
    }

    function abortActiveFetch() {
      // Abort serial fetch only (plan+apply cancel)
      if (_activeFetchAbort) {
        _activeFetchAbort.abort();
        _activeFetchAbort = null;
      }
      // Also tell the backend to stop the LLM call (fire-and-forget)
      fetch(BACKEND_URL + "/cancel", { method: "POST" }).catch(() => {});
    }

    function cancelJobFetch(jobId) {
      // Abort all fetches for a specific job
      const seqs = _jobIdToSeqs.get(jobId);
      if (seqs) {
        for (const seq of seqs) {
          const ac = _fetchAborts.get(seq);
          if (ac) ac.abort();
          _fetchAborts.delete(seq);
        }
        _jobIdToSeqs.delete(jobId);
      }
      // Tell the plugin to cancel the job
      postToPlugin({ type: "cancel-job", jobId });
    }

    // ── Parallel Job Queue ────────────────────────────────────────
    const _jobs = new Map(); // jobId -> { prompt, phase, phaseStartTime }
    let _jobTickInterval = null;

    // Phase ranges for single progress bar (0-100%)
    const JOB_PHASE_RANGES = {
      analyze:  [0, 15],
      generate: [15, 85],
      create:   [85, 100],
    };

    function addJob(jobId, prompt) {
      _jobs.set(jobId, {
        prompt: prompt,
        phase: "analyze",
        phaseStartTime: Date.now(),
      });
      renderJobItem(jobId);
      startJobTick();
    }

    function renderJobItem(jobId) {
      const job = _jobs.get(jobId);
      if (!job) return;
      // Truncate prompt for display
      const display = job.prompt.length > 40 ? job.prompt.slice(0, 37) + "…" : job.prompt;
      const el = document.createElement("div");
      el.className = "job-item";
      el.dataset.jobId = String(jobId);
      el.innerHTML =
        '<div class="job-header">' +
          '<span class="job-prompt" title="' + job.prompt.replace(/"/g, '&quot;') + '">' + display + '</span>' +
          '<span class="job-phase">Analyzing</span>' +
          '<button class="job-cancel" title="Cancel">✕</button>' +
        '</div>' +
        '<div class="job-bar-track"><div class="job-bar-fill"></div></div>';
      // Cancel handler
      el.querySelector(".job-cancel").addEventListener("click", () => {
        cancelJobFetch(jobId);
      });
      jobListEl.appendChild(el);
    }

    function updateJobPhase(jobId, phase) {
      const job = _jobs.get(jobId);
      if (!job) return;
      job.phase = phase;
      job.phaseStartTime = Date.now();
      const el = jobListEl.querySelector('[data-job-id="' + jobId + '"]');
      if (!el) return;
      const phaseLabels = { analyze: "Analyzing", generate: "Generating", create: "Creating" };
      const phaseEl = el.querySelector(".job-phase");
      if (phaseEl) phaseEl.textContent = phaseLabels[phase] || phase;
    }

    function completeJob(jobId, summary) {
      const job = _jobs.get(jobId);
      const el = jobListEl.querySelector('[data-job-id="' + jobId + '"]');
      if (el) {
        el.classList.add("done");
        const phaseEl = el.querySelector(".job-phase");
        if (phaseEl) phaseEl.textContent = "Done";
        const fillEl = el.querySelector(".job-bar-fill");
        if (fillEl) fillEl.style.width = "100%";
      }
      // Remove from job list after a delay
      setTimeout(() => {
        _jobs.delete(jobId);
        if (el) el.remove();
        maybeStopJobTick();
      }, 3000);
    }

    function errorJob(jobId, error) {
      const el = jobListEl.querySelector('[data-job-id="' + jobId + '"]');
      if (el) {
        el.classList.add("error");
        const phaseEl = el.querySelector(".job-phase");
        if (phaseEl) phaseEl.textContent = "Failed";
      }
      setTimeout(() => {
        _jobs.delete(jobId);
        if (el) el.remove();
        maybeStopJobTick();
      }, 4000);
    }

    function cancelledJob(jobId) {
      const el = jobListEl.querySelector('[data-job-id="' + jobId + '"]');
      if (el) {
        el.classList.add("cancelled");
        const phaseEl = el.querySelector(".job-phase");
        if (phaseEl) phaseEl.textContent = "Cancelled";
      }
      setTimeout(() => {
        _jobs.delete(jobId);
        if (el) el.remove();
        maybeStopJobTick();
      }, 2000);
    }

    function startJobTick() {
      if (_jobTickInterval) return;
      _jobTickInterval = setInterval(tickAllJobs, 80);
    }

    function maybeStopJobTick() {
      if (_jobs.size === 0 && _jobTickInterval) {
        clearInterval(_jobTickInterval);
        _jobTickInterval = null;
      }
    }

    function tickAllJobs() {
      for (const [jobId, job] of _jobs) {
        if (job.phase === "done" || job.phase === "error" || job.phase === "cancelled") continue;
        const el = jobListEl.querySelector('[data-job-id="' + jobId + '"] .job-bar-fill');
        if (!el) continue;
        const range = JOB_PHASE_RANGES[job.phase];
        if (!range) continue;
        const est = phaseEstimates[job.phase] || 30000;
        const elapsed = Date.now() - job.phaseStartTime;
        var phasePct;
        if (elapsed < est) {
          phasePct = 0.85 * (elapsed / est);
        } else {
          var overtime = elapsed - est;
          phasePct = 0.85 + 0.13 * (1 - Math.exp(-overtime / (est * 0.5)));
        }
        var overallPct = range[0] + (range[1] - range[0]) * phasePct;
        el.style.width = Math.min(overallPct, 98).toFixed(1) + "%";
      }
    }

    // ── Cancel guard: suppress stale plugin messages after cancel ──
    let _cancelledAt = 0;
    const CANCEL_GUARD_MS = 5000; // ignore generation messages for 5s after cancel
    function isCancelGuardActive() {
      return _cancelledAt > 0 && (Date.now() - _cancelledAt) < CANCEL_GUARD_MS;
    }

    // ── Button Handlers ───────────────────────────────────────────
    btnApply.addEventListener("click", () => {
      if (!_apiKey) {
        setStatus("Please configure your API key in Settings first.", "error");
        return;
      }
      const intent = intentEl.value.trim();
      if (!intent) {
        setStatus("Please describe what you want to change.", "error");
        return;
      }
      _cancelledAt = 0; // clear cancel guard for new run
      postToPlugin({ type: "run", intent });
    });

    btnCancel.addEventListener("click", () => {
      // Set cancel guard to suppress any late-arriving plugin messages
      _cancelledAt = Date.now();
      // Abort in-flight fetch instantly (AbortController)
      abortActiveFetch();
      // Tell the plugin to set _cancelled flag
      postToPlugin({ type: "cancel" });
      // Immediately reset ALL UI — no setTimeout, no waiting for plugin
      stopProgress();
      hideWorking();
      setStatus("Cancelled.", "error");
    });

    // ── Ctrl+Enter to apply ───────────────────────────────────
    intentEl.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        if (!btnApply.disabled) btnApply.click();
      }
    });

    // ── Receive from Plugin ───────────────────────────────────────
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case "apply-success": {
          if (isCancelGuardActive()) break; // suppress stale message
          intentEl.value = "";
          advanceToPhase("done");
          setTimeout(() => { stopProgress(); hideWorking(); }, 600);
          setStatus(msg.summary, "success");
          break;
        }
        case "apply-error": {
          if (isCancelGuardActive()) break; // suppress stale message
          setStatus(msg.error, "error");
          stopProgress();
          hideWorking();
          break;
        }
        case "revert-success": {
          setStatus("Undo successful.", "success");
          break;
        }
        case "revert-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "do-fetch": {
          if (isCancelGuardActive() && !msg.jobId) break; // only guard serial fetches
          doFetchForPlugin(msg.endpoint, msg.body, msg.seq, msg.jobId);
          break;
        }
        case "status": {
          if (isCancelGuardActive()) break; // suppress stale progress updates
          // Map status messages to progress phases (only update progress, not status bar)
          const m = (msg.message || "").toLowerCase();
          if (m.includes("analyz") || m.includes("extract") || m.includes("design system")) {
            advanceToPhase("analyze");
          } else if (m.includes("generat") || m.includes("thinking")) {
            advanceToPhase("generate");
          } else if (m.includes("creat") || m.includes("canvas") || m.includes("applying")) {
            advanceToPhase("create");
          }
          break;
        }
        case "export-json-result": {
          downloadJson(msg.data);
          setStatus("JSON saved.", "success");
          break;
        }
        case "export-json-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "docs-result": {
          downloadMarkdown(msg.markdown, msg.filename);
          setStatus("Design docs saved.", "success");
          break;
        }
        case "docs-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "audit-phase": {
          if (msg.phase === "scanning") {
            startAuditProgress(msg.scope || "all");
          } else if (msg.phase === "enhancing") {
            advanceAuditPhase("enhancing");
          }
          break;
        }
        case "audit-results": {
          advanceAuditPhase("done");
          auditPanel.style.display = "flex";
          renderAuditFindings(msg.findings);
          var issueCount = (msg.findings || []).length;
          setStatus("Audit complete: " + issueCount + " issue" + (issueCount === 1 ? "" : "s") + " found", issueCount > 0 ? "warning" : "success");
          break;
        }
        case "audit-error": {
          stopAuditProgress();
          setStatus(msg.error, "error");
          break;
        }
        case "load-audit-timings": {
          if (msg.timings) {
            if (msg.timings.all) auditEstimates.all = msg.timings.all;
            if (msg.timings.frame) auditEstimates.frame = msg.timings.frame;
            if (msg.timings.component) auditEstimates.component = msg.timings.component;
          }
          break;
        }
        case "import-json-success": {
          setStatus(msg.summary, "success");
          break;
        }
        case "import-json-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "generate-success": {
          if (isCancelGuardActive()) break; // suppress stale message
          intentEl.value = "";
          advanceToPhase("done");
          setTimeout(() => { stopProgress(); hideWorking(); }, 600);
          setStatus(msg.summary, "success");
          break;
        }
        case "generate-error": {
          if (isCancelGuardActive()) break; // suppress stale message
          setStatus(msg.error, "error");
          stopProgress();
          hideWorking();
          break;
        }
        case "generate-cancelled": {
          // Already handled by cancel click — just confirm
          stopProgress();
          hideWorking();
          setStatus("Cancelled.", "error");
          break;
        }

        // ── Parallel Job Messages ─────────────────────────────
        case "job-started": {
          // Exit serial mode (showWorking/startProgress may have been called)
          stopProgress();
          hideWorking();
          addJob(msg.jobId, msg.prompt);
          intentEl.value = "";
          setStatus("Job started — you can submit more prompts", "success");
          break;
        }
        case "job-progress": {
          updateJobPhase(msg.jobId, msg.phase);
          break;
        }
        case "job-complete": {
          completeJob(msg.jobId, msg.summary);
          setStatus(msg.summary, "success");
          break;
        }
        case "job-error": {
          errorJob(msg.jobId, msg.error);
          setStatus(msg.error, "error");
          break;
        }
        case "job-cancelled": {
          cancelledJob(msg.jobId);
          break;
        }
        case "selection-change": {
          setSelectionStatus(msg.label);
          updateButtonLabel(msg.label !== "Nothing selected — will generate new frame");
          break;
        }
        case "load-timings": {
          if (msg.timings) {
            if (msg.timings.analyze) phaseEstimates.analyze = msg.timings.analyze;
            if (msg.timings.generate) phaseEstimates.generate = msg.timings.generate;
            if (msg.timings.create) phaseEstimates.create = msg.timings.create;
          }
          break;
        }
        case "startup-ready": {
          const overlay = document.getElementById("loading-overlay");
          if (overlay) {
            overlay.classList.add("hidden");
            setTimeout(() => overlay.remove(), 300);
          }
          break;
        }
        case "load-api-key": {
          const key = msg.key || "";
          const provider = msg.provider || "anthropic";
          const model = msg.model || "";
          // Load all saved keys
          if (msg.allKeys) {
            Object.assign(_providerKeys, msg.allKeys);
          }
          // Set provider and model
          _selectedProvider = provider;
          providerSelect.value = provider;
          populateModelDropdown(provider);
          if (model) {
            _selectedModel = model;
            modelSelect.value = model;
          }
          // Update key UI for current provider
          apiKeyLabel.textContent = PROVIDER_KEY_LABELS[provider] || "API Key";
          updateKeyStatus(key);
          if (key) {
            apiKeyInput.value = "";
            apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[provider].slice(0, -1) + key.slice(-4);
          } else {
            apiKeyInput.placeholder = PROVIDER_KEY_PLACEHOLDERS[provider] || "Enter API key\u2026";
          }
          break;
        }
      }
    };
  </script>
</body>
</html>
