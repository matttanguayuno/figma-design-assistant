<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>DesignOps AI</title>
  <style>
    :root {
      --bg: #1e1e1e;
      --surface: #2d2d2d;
      --border: #3e3e3e;
      --text: #e0e0e0;
      --text-muted: #999;
      --accent: #6c5ce7;
      --accent-hover: #7c6df7;
      --success: #00b894;
      --danger: #d63031;
      --font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font);
      font-size: 12px;
      color: var(--text);
      background: var(--bg);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    label {
      font-weight: 600;
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    textarea {
      width: 100%;
      min-height: 72px;
      padding: 10px;
      font-family: var(--font);
      font-size: 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      resize: vertical;
      outline: none;
      transition: border-color 0.15s;
    }

    textarea:focus {
      border-color: var(--accent);
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    button {
      flex: 1;
      padding: 8px 12px;
      font-family: var(--font);
      font-size: 12px;
      font-weight: 600;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, opacity 0.15s;
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
    }
    .btn-primary:hover:not(:disabled) {
      background: var(--accent-hover);
    }

    .btn-danger {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid var(--border);
      flex: 0 0 auto;
      padding: 8px 16px;
    }
    .btn-danger:hover:not(:disabled) {
      color: var(--danger);
      border-color: var(--danger);
    }

    /* ── Cancel Button ──────────────────────────────── */
    .btn-cancel {
      flex: 1;
      padding: 8px 16px;
      background: var(--surface);
      color: var(--text);
      border: 1px solid var(--border);
      font-family: var(--font);
      font-size: 12px;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
      display: none;
    }
    .btn-cancel:hover {
      color: var(--danger);
      border-color: var(--danger);
      background: rgba(214, 48, 49, 0.1);
    }

    /* ── Progress Bar (Segmented) ───────────────────── */
    .progress-container {
      display: none;
      flex-direction: column;
      gap: 0;
    }
    .progress-container.visible {
      display: flex;
    }
    .progress-segments {
      display: flex;
      gap: 3px;
    }
    .progress-segment {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }
    .segment-track {
      height: 4px;
      background: var(--surface);
      border-radius: 2px;
      overflow: hidden;
    }
    .segment-fill {
      height: 100%;
      width: 0%;
      border-radius: 2px;
      transition: width 0.15s linear;
      background: var(--accent);
    }
    .segment-label {
      text-align: center;
      font-size: 9px;
      color: var(--text-muted);
      opacity: 0.35;
      transition: opacity 0.3s, color 0.3s;
    }
    .progress-segment.active .segment-fill {
      background: var(--accent);
    }
    .progress-segment.active .segment-label {
      opacity: 1;
      color: var(--accent);
      font-weight: 600;
    }
    .progress-segment.done .segment-fill {
      width: 100% !important;
      background: var(--success);
    }
    .progress-segment.done .segment-label {
      opacity: 0.7;
      color: var(--success);
    }

    .status-bar {
      font-size: 10px;
      padding: 4px 0;
      border-radius: 0;
      background: transparent;
      color: var(--text-muted);
      text-align: center;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      border-top: 1px solid var(--border);
    }
    .status-bar::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-muted);
      flex-shrink: 0;
    }

    .status-bar.success {
      color: var(--success);
    }
    .status-bar.success::before {
      background: var(--success);
    }
    .status-bar.error {
      color: var(--danger);
    }
    .status-bar.error::before {
      background: var(--danger);
    }

    /* ── Label row with menu ─────────────────────────── */
    .label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .menu-wrapper {
      position: relative;
    }

    .menu-toggle {
      flex: none;
      width: 24px;
      height: 24px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s, color 0.15s;
    }
    .menu-toggle:hover {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .menu-toggle.open {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .menu-dropdown {
      display: none;
      position: absolute;
      right: 0;
      top: 32px;
      min-width: 180px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      z-index: 100;
      padding: 4px 0;
      animation: menuFadeIn 0.1s ease;
    }
    .menu-dropdown.show {
      display: block;
    }

    @keyframes menuFadeIn {
      from { opacity: 0; transform: translateY(-4px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: 8px;
      width: 100%;
      padding: 7px 12px;
      font-family: var(--font);
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      background: transparent;
      border: none;
      border-radius: 0;
      cursor: pointer;
      text-align: left;
      transition: background 0.1s;
    }
    .menu-item:hover {
      background: var(--accent);
      color: #fff;
    }
    .menu-item svg {
      flex-shrink: 0;
      width: 14px;
      height: 14px;
    }

    .menu-separator {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* ── Loading Overlay ─────────────────────────────── */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      z-index: 999;
      transition: opacity 0.3s;
    }
    .loading-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid var(--surface);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-text {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* ── Settings Panel ──────────────────────────────── */
    .settings-panel {
      display: none;
      flex-direction: column;
      gap: 8px;
      padding: 10px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      animation: menuFadeIn 0.15s ease;
    }
    .settings-panel.visible {
      display: flex;
    }
    .settings-label {
      font-size: 10px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .settings-row {
      display: flex;
      gap: 6px;
    }
    .settings-input {
      flex: 1;
      padding: 6px 8px;
      font-family: var(--font);
      font-size: 11px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      outline: none;
    }
    .settings-input:focus {
      border-color: var(--accent);
    }
    .settings-input::placeholder {
      color: var(--text-muted);
      opacity: 0.5;
    }
    .btn-save-key {
      flex: none;
      padding: 6px 10px;
      font-family: var(--font);
      font-size: 11px;
      font-weight: 600;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .btn-save-key:hover {
      background: var(--accent-hover);
    }
    .key-status {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .key-status.connected {
      color: var(--success);
    }
    .key-status.missing {
      color: var(--danger);
    }
    .key-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .key-status.connected .key-dot {
      background: var(--success);
    }
    .key-status.missing .key-dot {
      background: var(--danger);
    }
  </style>
</head>
<body>
  <div id="loading-overlay" class="loading-overlay">
    <div class="spinner"></div>
    <div class="loading-text">Initializing…</div>
  </div>

  <div>
    <div class="label-row">
      <label for="intent">Describe changes</label>
      <div class="menu-wrapper">
        <button id="menu-toggle" class="menu-toggle" title="Menu" aria-label="Menu">
          <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
            <path d="M8 9.5L4 5.5h8L8 9.5z" fill="currentColor"/>
          </svg>
        </button>
        <div id="menu-dropdown" class="menu-dropdown">
          <button class="menu-item" id="menu-export-json">
            <svg viewBox="0 0 16 16" fill="none"><path d="M4 1h5l4 4v9a1 1 0 01-1 1H4a1 1 0 01-1-1V2a1 1 0 011-1z" stroke="currentColor" stroke-width="1.2"/><path d="M9 1v4h4" stroke="currentColor" stroke-width="1.2"/><path d="M6 9l2 2 2-2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            Export to JSON
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-import-json">
            <svg viewBox="0 0 16 16" fill="none"><path d="M4 1h5l4 4v9a1 1 0 01-1 1H4a1 1 0 01-1-1V2a1 1 0 011-1z" stroke="currentColor" stroke-width="1.2"/><path d="M9 1v4h4" stroke="currentColor" stroke-width="1.2"/><path d="M6 11l2-2 2 2" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            Import from JSON
          </button>
          <div class="menu-separator"></div>
          <button class="menu-item" id="menu-settings">
            <svg viewBox="0 0 16 16" fill="none"><path d="M6.5 1h3l.4 2 1.3.7 1.8-1 2.1 2.1-1 1.8.7 1.3 2 .4v3l-2 .4-1.3.7 1 1.8-2.1 2.1-1.8-1-.7 1.3-.4 2h-3l-.4-2-1.3-.7-1.8 1L.9 13.1l1-1.8L1.2 10l-2-.4v-3l2-.4.7-1.3-1-1.8L3 .9l1.8 1L6.1 1.2l.4-2z" stroke="currentColor" stroke-width="1.1"/><circle cx="8" cy="8" r="2.5" stroke="currentColor" stroke-width="1.1"/></svg>
            Settings
          </button>
        </div>
      </div>
    </div>
    <textarea
      id="intent"
      placeholder="e.g. Add a login screen, make the header larger, change background to blue…"
    ></textarea>
  </div>

  <div class="btn-row">
    <button id="btn-apply" class="btn-primary" disabled>Apply</button>
    <button id="btn-cancel" class="btn-cancel">Cancel</button>
  </div>

  <div id="settings-panel" class="settings-panel">
    <div class="settings-label">Anthropic API Key</div>
    <div class="settings-row">
      <input id="api-key-input" class="settings-input" type="password" placeholder="sk-ant-api03-…" spellcheck="false" autocomplete="off" />
      <button id="btn-save-key" class="btn-save-key">Save</button>
    </div>
    <div id="key-status" class="key-status missing">
      <span class="key-dot"></span>
      <span id="key-status-text">No API key configured</span>
    </div>
  </div>

  <div id="progress-container" class="progress-container">
    <div class="progress-segments">
      <div class="progress-segment" data-step="analyze">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Analyzing</div>
      </div>
      <div class="progress-segment" data-step="generate">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Generating</div>
      </div>
      <div class="progress-segment" data-step="create">
        <div class="segment-track"><div class="segment-fill"></div></div>
        <div class="segment-label">Creating</div>
      </div>
    </div>
  </div>

  <div id="status-bar" class="status-bar">Nothing selected — will generate new frame</div>

  <!-- Hidden file input for JSON import -->
  <input type="file" id="file-input" accept=".json" style="display:none" />

  <script>
    // ── DOM References ────────────────────────────────────────────
    const intentEl = document.getElementById("intent");
    const btnApply = document.getElementById("btn-apply");
    const btnCancel = document.getElementById("btn-cancel");
    const statusBar = document.getElementById("status-bar");
    const menuToggle = document.getElementById("menu-toggle");
    const menuDropdown = document.getElementById("menu-dropdown");
    const menuExportJson = document.getElementById("menu-export-json");
    const menuImportJson = document.getElementById("menu-import-json");
    const fileInput = document.getElementById("file-input");
    const progressContainer = document.getElementById("progress-container");
    const progressSegments = document.querySelectorAll(".progress-segment");
    const settingsPanel = document.getElementById("settings-panel");
    const apiKeyInput = document.getElementById("api-key-input");
    const btnSaveKey = document.getElementById("btn-save-key");
    const keyStatus = document.getElementById("key-status");
    const keyStatusText = document.getElementById("key-status-text");
    const menuSettings = document.getElementById("menu-settings");

    // ── API Key state ────────────────────────────────────────────
    let _apiKey = "";

    function updateKeyStatus(key) {
      _apiKey = key || "";
      if (_apiKey) {
        keyStatus.className = "key-status active";
        keyStatusText.textContent = "API key configured";
        btnApply.disabled = false;
      } else {
        keyStatus.className = "key-status missing";
        keyStatusText.textContent = "No API key configured";
        btnApply.disabled = true;
      }
    }

    // Track whether anything is selected to update button label
    let hasSelection = false;
    function updateButtonLabel(selected) {
      hasSelection = selected;
      btnApply.textContent = selected ? "Apply" : "Generate";
    }

    // ── Progress Bar (segmented, timing-adaptive) ──────────────────
    //
    // Strategy: 3 independent segments, one per phase. The active
    // segment fills based on estimated time; completed segments snap
    // to 100% green. No positional confusion — label sits below its bar.
    // After each run, timings are persisted via figma.clientStorage.

    // Default estimates (ms). Updated after each successful run.
    let phaseEstimates = { analyze: 5000, generate: 45000, create: 4000 };
    const PHASE_ORDER = ["analyze", "generate", "create"];

    let _progressInterval = null;
    let _progressPhase = "";
    let _phaseStartTime = 0;
    let _phaseTimings = {};

    function getSegmentFill(phase) {
      const seg = document.querySelector('.progress-segment[data-step="' + phase + '"]');
      return seg ? seg.querySelector(".segment-fill") : null;
    }

    function startProgress(phase) {
      progressContainer.classList.add("visible");
      _progressPhase = phase || "analyze";
      _phaseStartTime = Date.now();
      _phaseTimings = {};
      _phaseTimings[_progressPhase] = Date.now();
      // Reset all segments
      progressSegments.forEach(function(seg) {
        seg.classList.remove("active", "done");
        seg.querySelector(".segment-fill").style.width = "0%";
      });
      updateStepIndicators(_progressPhase);
      if (_progressInterval) clearInterval(_progressInterval);
      _progressInterval = setInterval(tickProgress, 80);
    }

    function tickProgress() {
      var fill = getSegmentFill(_progressPhase);
      if (!fill) return;
      var est = phaseEstimates[_progressPhase] || 30000;
      var elapsed = Date.now() - _phaseStartTime;
      var pct;
      if (elapsed < est) {
        pct = 85 * (elapsed / est);
      } else {
        var overtime = elapsed - est;
        pct = 85 + 13 * (1 - Math.exp(-overtime / (est * 0.5)));
      }
      fill.style.width = Math.min(pct, 98).toFixed(1) + "%";
    }

    function advanceToPhase(phase) {
      if (phase === _progressPhase) return;

      // Record timing for finished phase
      var prevPhase = _progressPhase;
      if (_phaseTimings[prevPhase]) {
        var actualMs = Date.now() - _phaseTimings[prevPhase];
        phaseEstimates[prevPhase] = Math.round(actualMs * 0.7 + phaseEstimates[prevPhase] * 0.3);
      }

      // Mark previous segment as done (CSS handles 100% fill + green)
      var prevSeg = document.querySelector('.progress-segment[data-step="' + prevPhase + '"]');
      if (prevSeg) { prevSeg.classList.remove("active"); prevSeg.classList.add("done"); }

      if (phase === "done") {
        // Mark all segments done
        progressSegments.forEach(function(seg) {
          seg.classList.remove("active");
          seg.classList.add("done");
        });
        if (_progressInterval) { clearInterval(_progressInterval); _progressInterval = null; }
        // Save timings to plugin sandbox for persistence
        postToPlugin({ type: "save-timings", timings: phaseEstimates });
        return;
      }

      _progressPhase = phase;
      _phaseStartTime = Date.now();
      _phaseTimings[phase] = Date.now();
      updateStepIndicators(phase);
    }

    function updateStepIndicators(phase) {
      var idx = PHASE_ORDER.indexOf(phase);
      progressSegments.forEach(function(seg, i) {
        seg.classList.remove("active", "done");
        if (i < idx) seg.classList.add("done");
        else if (i === idx) seg.classList.add("active");
      });
    }

    function stopProgress() {
      if (_progressInterval) clearInterval(_progressInterval);
      _progressInterval = null;
      progressContainer.classList.remove("visible");
      progressSegments.forEach(function(seg) {
        seg.classList.remove("active", "done");
        seg.querySelector(".segment-fill").style.width = "0%";
      });
    }

    function showWorking() {
      btnApply.style.display = "none";
      btnCancel.style.display = "block";
      statusBar.style.display = "none";
    }

    function hideWorking() {
      btnApply.style.display = "block";
      btnCancel.style.display = "none";
      btnApply.disabled = !_apiKey;
      statusBar.style.display = "flex";
    }

    // ── Helpers ───────────────────────────────────────────────────
    function setStatus(msg, type) {
      statusBar.textContent = msg;
      statusBar.className = "status-bar" + (type ? " " + type : "");
    }

    // Track current selection label for restoring after transient status
    let _selectionLabel = "Nothing selected";
    function setSelectionStatus(msg) {
      _selectionLabel = msg;
      // Only update if we're not showing a transient status (success/error)
      if (!statusBar.classList.contains("success") && !statusBar.classList.contains("error")) {
        statusBar.textContent = msg;
        statusBar.className = "status-bar";
      }
    }

    // Override setStatus to auto-revert to selection label after success/error
    const _origSetStatus = setStatus;
    function setStatus(msg, type) {
      statusBar.textContent = msg;
      statusBar.className = "status-bar" + (type ? " " + type : "");
      // Revert to selection status after a few seconds for success/error
      if (type === "success" || type === "error") {
        setTimeout(() => {
          // Only revert if it's still showing the same message
          if (statusBar.textContent === msg) {
            statusBar.textContent = _selectionLabel;
            statusBar.className = "status-bar";
          }
        }, 4000);
      }
    }

    // ── Send to Plugin ────────────────────────────────────────────
    function postToPlugin(msg) {
      parent.postMessage({ pluginMessage: msg }, "*");
    }

    // ── Menu Toggle ──────────────────────────────────────────────
    menuToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      const isOpen = menuDropdown.classList.toggle("show");
      menuToggle.classList.toggle("open", isOpen);
    });

    // Close menu when clicking outside
    document.addEventListener("click", (e) => {
      if (!menuDropdown.contains(e.target) && e.target !== menuToggle) {
        menuDropdown.classList.remove("show");
        menuToggle.classList.remove("open");
      }
    });

    // ── Menu: Settings ──────────────────────────────────────────
    menuSettings.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      settingsPanel.classList.toggle("visible");
    });

    // ── Save API Key ─────────────────────────────────────────────
    btnSaveKey.addEventListener("click", () => {
      const key = apiKeyInput.value.trim();
      if (!key) {
        setStatus("Please enter an API key.", "error");
        return;
      }
      updateKeyStatus(key);
      postToPlugin({ type: "save-api-key", key: key });
      apiKeyInput.value = "";
      apiKeyInput.placeholder = "sk-ant-\u2026" + key.slice(-4);
      setStatus("API key saved.", "success");
    });

    // ── Menu: Export design to JSON ──────────────────────────────
    menuExportJson.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      setStatus("Exporting design to JSON…");
      postToPlugin({ type: "export-json" });
    });
    // \u2500\u2500 Menu: Import design from JSON \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
    menuImportJson.addEventListener("click", () => {
      menuDropdown.classList.remove("show");
      menuToggle.classList.remove("open");
      fileInput.value = "";
      fileInput.click();
    });

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;
      setStatus("Reading JSON file\u2026");
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          if (!data.selection || !data.selection.nodes) {
            setStatus("Invalid JSON: missing selection.nodes", "error");
            return;
          }
          setStatus("Importing design\u2026");
          postToPlugin({ type: "import-json", data: data });
        } catch (err) {
          setStatus("Invalid JSON file: " + err.message, "error");
        }
      };
      reader.onerror = () => setStatus("Failed to read file.", "error");
      reader.readAsText(file);
    });

    // ── Menu: Generate Frame ────────────────────────────────────
    // Removed — Generate is now handled automatically by Apply when nothing is selected
    function downloadJson(data) {
      const json = JSON.stringify(data, null, 2);
      const dataUri = "data:application/json;charset=utf-8," + encodeURIComponent(json);
      const a = document.createElement("a");
      a.href = dataUri;
      a.download = "design-export.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // ── Fetch Proxy (real AbortController for instant cancel) ──────
    // ▸ For local development:  "http://localhost:3001"
    // ▸ For Render deployment:  "https://figma-design-assistant.onrender.com"
    const BACKEND_URL = "https://figma-design-assistant.onrender.com";
    let _activeFetchAbort = null;

    function doFetchForPlugin(endpoint, body, seq) {
      // Abort any prior in-flight request
      if (_activeFetchAbort) { _activeFetchAbort.abort(); _activeFetchAbort = null; }
      const ac = new AbortController();
      _activeFetchAbort = ac;
      fetch(BACKEND_URL + endpoint, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body),
        signal: ac.signal,
      })
        .then(async (resp) => {
          _activeFetchAbort = null;
          if (!resp.ok) {
            const errText = await resp.text();
            postToPlugin({ type: "fetch-error", error: "Backend error " + resp.status + ": " + errText, seq });
          } else {
            const data = await resp.json();
            postToPlugin({ type: "fetch-result", data, seq });
          }
        })
        .catch((err) => {
          _activeFetchAbort = null;
          if (err.name === "AbortError") {
            postToPlugin({ type: "fetch-aborted", seq });
          } else {
            postToPlugin({ type: "fetch-error", error: err.message, seq });
          }
        });
    }

    function abortActiveFetch() {
      if (_activeFetchAbort) {
        _activeFetchAbort.abort();
        _activeFetchAbort = null;
      }
      // Also tell the backend to stop the LLM call (fire-and-forget)
      fetch(BACKEND_URL + "/cancel", { method: "POST" }).catch(() => {});
    }

    // ── Cancel guard: suppress stale plugin messages after cancel ──
    let _cancelledAt = 0;
    const CANCEL_GUARD_MS = 5000; // ignore generation messages for 5s after cancel
    function isCancelGuardActive() {
      return _cancelledAt > 0 && (Date.now() - _cancelledAt) < CANCEL_GUARD_MS;
    }

    // ── Button Handlers ───────────────────────────────────────────
    btnApply.addEventListener("click", () => {
      if (!_apiKey) {
        setStatus("Please configure your API key in Settings first.", "error");
        return;
      }
      const intent = intentEl.value.trim();
      if (!intent) {
        setStatus("Please describe what you want to change.", "error");
        return;
      }
      _cancelledAt = 0; // clear cancel guard for new run
      showWorking();
      startProgress("analyze");
      postToPlugin({ type: "run", intent });
    });

    btnCancel.addEventListener("click", () => {
      // Set cancel guard to suppress any late-arriving plugin messages
      _cancelledAt = Date.now();
      // Abort in-flight fetch instantly (AbortController)
      abortActiveFetch();
      // Tell the plugin to set _cancelled flag
      postToPlugin({ type: "cancel" });
      // Immediately reset ALL UI — no setTimeout, no waiting for plugin
      stopProgress();
      hideWorking();
      setStatus("Cancelled.", "error");
    });

    // ── Ctrl+Enter to apply ───────────────────────────────────
    intentEl.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
        e.preventDefault();
        if (!btnApply.disabled) btnApply.click();
      }
    });

    // ── Receive from Plugin ───────────────────────────────────────
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case "apply-success": {
          if (isCancelGuardActive()) break; // suppress stale message
          intentEl.value = "";
          advanceToPhase("done");
          setTimeout(() => { stopProgress(); hideWorking(); }, 600);
          setStatus(msg.summary, "success");
          break;
        }
        case "apply-error": {
          if (isCancelGuardActive()) break; // suppress stale message
          setStatus(msg.error, "error");
          stopProgress();
          hideWorking();
          break;
        }
        case "revert-success": {
          setStatus("Undo successful.", "success");
          break;
        }
        case "revert-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "do-fetch": {
          if (isCancelGuardActive()) break; // don't start fetch if cancelled
          doFetchForPlugin(msg.endpoint, msg.body, msg.seq);
          break;
        }
        case "status": {
          if (isCancelGuardActive()) break; // suppress stale progress updates
          // Map status messages to progress phases (only update progress, not status bar)
          const m = (msg.message || "").toLowerCase();
          if (m.includes("analyz") || m.includes("extract") || m.includes("design system")) {
            advanceToPhase("analyze");
          } else if (m.includes("generat") || m.includes("thinking")) {
            advanceToPhase("generate");
          } else if (m.includes("creat") || m.includes("canvas") || m.includes("applying")) {
            advanceToPhase("create");
          }
          break;
        }
        case "export-json-result": {
          downloadJson(msg.data);
          setStatus("JSON saved.", "success");
          break;
        }
        case "export-json-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "import-json-success": {
          setStatus(msg.summary, "success");
          break;
        }
        case "import-json-error": {
          setStatus(msg.error, "error");
          break;
        }
        case "generate-success": {
          if (isCancelGuardActive()) break; // suppress stale message
          intentEl.value = "";
          advanceToPhase("done");
          setTimeout(() => { stopProgress(); hideWorking(); }, 600);
          setStatus(msg.summary, "success");
          break;
        }
        case "generate-error": {
          if (isCancelGuardActive()) break; // suppress stale message
          setStatus(msg.error, "error");
          stopProgress();
          hideWorking();
          break;
        }
        case "generate-cancelled": {
          // Already handled by cancel click — just confirm
          stopProgress();
          hideWorking();
          setStatus("Cancelled.", "error");
          break;
        }
        case "selection-change": {
          setSelectionStatus(msg.label);
          updateButtonLabel(msg.label !== "Nothing selected — will generate new frame");
          break;
        }
        case "load-timings": {
          if (msg.timings) {
            if (msg.timings.analyze) phaseEstimates.analyze = msg.timings.analyze;
            if (msg.timings.generate) phaseEstimates.generate = msg.timings.generate;
            if (msg.timings.create) phaseEstimates.create = msg.timings.create;
          }
          break;
        }
        case "startup-ready": {
          const overlay = document.getElementById("loading-overlay");
          if (overlay) {
            overlay.classList.add("hidden");
            setTimeout(() => overlay.remove(), 300);
          }
          break;
        }
        case "load-api-key": {
          const key = msg.key || "";
          updateKeyStatus(key);
          if (key) {
            apiKeyInput.value = "";
            apiKeyInput.placeholder = "sk-ant-\u2026" + key.slice(-4);
          }
          break;
        }
      }
    };
  </script>
</body>
</html>
